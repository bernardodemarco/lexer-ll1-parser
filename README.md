# Lexer & Parser LL(1) Implementation

This project consists of a Lexer and LL(1) Parser implementation in Java of a learning-purposes invented language called `LSI-2024-2`.

## Language `LSI-2024-2`

Below, it is described the language's grammar:

<details>
<summary><code>LSI-2024-2</code> grammar:</summary>

```
MAIN → STMT | FLIST | ε
FLIST → FDEF FLIST | FDEF
FDEF → def id(PARLIST){STMTLIST}
PARLIST → int id, PARLIST | int id | ε
VARLIST → id, VARLIST | id
STMT → int VARLIST;
 | ATRIBST;
 | PRINTST;
 | RETURNST;
 | IFSTMT
 | {STMTLIST}
 | ;
ATRIBST → id := EXPR | id := FCALL
FCALL → id(PARLISTCALL)
PARLISTCALL → id, PARLISTCALL | id | ε
PRINTST → print EXPR
RETURNST → return id | return
IFSTMT → if(EXPR) STMT else STMT
 | if(EXPR) STMT
STMTLIST → STMT STMTLIST | STMT
EXPR → NUMEXPR < NUMEXPR
 | NUMEXPR <= NUMEXPR
 | NUMEXPR > NUMEXPR
 | NUMEXPR >= NUMEXPR
 | NUMEXPR == NUMEXPR
 | NUMEXPR <> NUMEXPR
 | NUMEXPR
NUMEXPR → NUMEXPR + TERM
 | NUMEXPR - TERM
 | TERM
TERM → TERM * FACTOR
 | TERM / FACTOR
 | FACTOR
FACTOR → num | (NUMEXPR) | id
```
</details>

It can be observed that the `LSI-2024-2` language encompasses 17 non-terminal and 25 terminal tokens.

## Lexer Implementation

The Lexer tokenizes all types of terminal tokens. Its core workflow consists in, first, generating a symbols table that initially stores all keywords and special characters, such as arithmetic operators. The table has been designed in a `HashMap`, in which the token's lexemes are the keys, and the tokens are the values. 

https://github.com/bernardodemarco/lexer/blob/a769f1417b1b2a7f72a353ab4e51ef7be90d82bf/src/lexer/Lexer.java#L24-L32

Later in its scanning workflow, the lexer consumes an `LSI-2024-2` source file and tokenizes its contents. If a character is not recognized by the Lexer, an `UnrecognizedCharacterException` is thrown, informing the user the line and column where the unrecognized character was found.

https://github.com/bernardodemarco/lexer/blob/a769f1417b1b2a7f72a353ab4e51ef7be90d82bf/src/lexer/Lexer.java#L53-L77

As the tokens are generated, they are inserted in the symbols table and in a list. After all the `LSI-2024-02` file is scanned, the Lexer returns to the compiler a tuple, with the list of tokens and the symbols table.

https://github.com/bernardodemarco/lexer/blob/a769f1417b1b2a7f72a353ab4e51ef7be90d82bf/src/lexer/Lexer.java#L38-L48

## LL(1) Parser Implementation

With the purpose of implementing the parser with the LL(1) algorithm, the `LSI-2024-2` language was normalized into a LL(1) grammar. This was achieved by removing left recursion and left factoring the grammar's productions. Additionally, some tweaks were necessary to make it unambiguous. 

The [Princeton University LL(1) parser visualization tool](https://www.cs.princeton.edu/courses/archive/spring20/cos320/LL1/) was used to generate the grammar's transition table. The table was implemented as a map of maps.

https://github.com/bernardodemarco/lexer/blob/a769f1417b1b2a7f72a353ab4e51ef7be90d82bf/src/parser/Grammar.java#L28-L41

After these steps, it was possible to implement the core LL(1) algorithm. The parser receives the tokens and symbols table generated by the Lexer. It initializes a stack, with the `SpecialSymbol.END_OF_INPUT` (`$`) and `Grammar.SpecialSymbols.START_SYMBOL` (`MAIN`) lexemes. According to the symbol at the top of the stack, its corresponding production body is retrieved and pushed onto the stack in reverse order:

https://github.com/bernardodemarco/lexer/blob/a769f1417b1b2a7f72a353ab4e51ef7be90d82bf/src/parser/Parser.java#L44-L52

If the symbol at the stop of the stack is a terminal, it is checked whether it matches the current token being parsed. If so, the top element of the stack is removed and the next token is retrieved:

https://github.com/bernardodemarco/lexer/blob/a769f1417b1b2a7f72a353ab4e51ef7be90d82bf/src/parser/Parser.java#L31-L42

## Execution Example

The `run.sh` script was created to execute the compiler. When executing it, the user is asked to select which `LSI-2024-2` source file should be compiled:

```
➜  ./run.sh                              
Lexer & LL(1) Parser Implementation
-----------------------------------
4 LSI source files are available:
(1) - src/resources/lsi/fibonacci.lsi
(2) - src/resources/lsi/fibonacci-with-syntax-errors.lsi
(3) - src/resources/lsi/recursive-factorial.lsi
(4) - src/resources/lsi/recursive-factorial-with-syntax-errors.lsi
(0) - Enter 0 to exit
```

After the Lexer executes, it prints the generated list of tokens and the symbols table:

```
TOKENS
[KEYWORD['def'], IDENTIFIER['fibonacci'], SYMBOL['('], KEYWORD['int'], IDENTIFIER['position'], SYMBOL[')'], SYMBOL['{'], KEYWORD['if'], SYMBOL['('], IDENTIFIER['position'], RELATIONAL_OPERATOR['=='], NUMBER['0'], SYMBOL[')'], SYMBOL['{'], KEYWORD['return'], IDENTIFIER['position'], SYMBOL[';'], SYMBOL['}'], KEYWORD['if'], SYMBOL['('], IDENTIFIER['position'], RELATIONAL_OPERATOR['=='], NUMBER['1'], SYMBOL[')'], SYMBOL['{'], KEYWORD['return'], IDENTIFIER['position'], SYMBOL[';'], SYMBOL['}'], KEYWORD['int'], IDENTIFIER
# ...

SYMBOLS
{second_recursive_call=IDENTIFIER['second_recursive_call'], <==RELATIONAL_OPERATOR['<='], fibonacci=IDENTIFIER['fibonacci'], <>=RELATIONAL_OPERATOR['<>'], :==SYMBOL[':='], def=KEYWORD['def'], main=IDENTIFIER['main'], sum_of_recursive_calls=IDENTIFIER['sum_of_recursive_calls'], result=IDENTIFIER['result'], else=KEYWORD['else'], if=KEYWORD['if'], ===RELATIONAL_OPERATOR['=='], $=SYMBOL
# ...
```

The Parser prints the productions that were used, which can be used to build the program's Parse Trees:

```
DEBUG - Symbol at the top of the stack: [MAIN], input token: [KEYWORD['def']]
MAIN -> FLIST
DEBUG - Symbol at the top of the stack: [FLIST], input token: [KEYWORD['def']]
FLIST -> FDEF FLIST'
DEBUG - Symbol at the top of the stack: [FDEF], input token: [KEYWORD['def']]
FDEF -> def id ( PARLIST ) { STMTLIST }
DEBUG - Symbol at the top of the stack: [def], input token: [KEYWORD['def']]
# ...
EXPR' -> ε
DEBUG - Symbol at the top of the stack: [ε], input token: [SYMBOL[';']]
DEBUG - Symbol at the top of the stack: [;], input token: [SYMBOL[';']]
DEBUG - Symbol at the top of the stack: [STMTLIST'], input token: [SYMBOL['}']]
STMTLIST' -> ε
DEBUG - Symbol at the top of the stack: [ε], input token: [SYMBOL['}']]
DEBUG - Symbol at the top of the stack: [}], input token: [SYMBOL['}']
```
